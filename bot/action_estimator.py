"""
Contains class with methods to estimate actions.

"""
from bot.bot_game_state import BotGameState
from game_client.actions import Action
from game_client.map_hexes import Base, Catapult, HardRepair, LightRepair
from game_client.server_interaction import ActionCode
from game_client.vehicles import Vehicle
from utility.coordinates import Coords


class ActionEstimator:
    """
    Provides methods for action's 'usefulness' estimation.

    """

    def __init__(
        self, game_state: BotGameState, weights: list[float, float, float, float, float]
    ):
        """
        :param game_state: game state from the bot
        :param weights: float outcome modifiers for methods
            in the corresponding order:
                0 - enemy_atk_to_hp_ratio
                1 - straight_distance_to_base
                2 - gained_capture_points
                3 - estimate_targets
                4 - score_for_special_hexes
        """
        self.game_state = game_state
        self.weights = weights

    def __call__(self, action: Action) -> float:
        result = 0.0
        position = (
            action.target
            if action.action_code == ActionCode.MOVE
            else action.actor.position
        )

        result += self.enemy_atk_to_hp_ratio(action.actor, position)
        result += self.straight_distance_to_base(position)
        result += self.score_for_special_hexes(action.actor, position)
        result += self.gained_capture_points(action.actor, position)

        if action.action_code == ActionCode.SHOOT:
            result += self.estimate_targets(
                action.actor.damage, action.affected_vehicles
            )

        return result

    def enemy_atk_to_hp_ratio(self, actor: Vehicle, position: Coords) -> float:
        """
        Metric for a rough estimation of chance to be killed on the given pos.

        Calculates relation of summarised attack of enemies that can attack
        actor on the given position to current actor's hp.
        More enemies - higher the metric
        More actor.hp - lower the metric
        """
        close_enemies = self.__get_potential_shooters(position)
        return self.weights[0] * sum(enemy.damage for enemy in close_enemies) / actor.hp

    def straight_distance_to_base(self, position: Coords) -> float:
        """
        Calculates straight distance to base if there were no obstacles on the map.

        Not very representative metric as real distance to base
        is not the same thing but calculating real distance every time
        is very time-consuming, possible improvement: calculate distance
        to base on map creation process by using BFS from base hexes.
        Furthermore, base will not always be at the center of the map.
        """
        return self.weights[1] * position.straight_dist_to(Coords((0, 0, 0)))

    def gained_capture_points(self, actor: Vehicle, new_pos: Coords) -> float:
        """
        Calculates an amount of capture points generated.

        """
        result = 0
        prev_pos_hex = self.game_state.get_hex(actor.position).map_hex
        new_pos_hex = self.game_state.get_hex(new_pos).map_hex
        if isinstance(prev_pos_hex, Base) and not isinstance(new_pos_hex, Base):
            result += -actor.capture_points
        if isinstance(prev_pos_hex, Base) and isinstance(new_pos_hex, Base):
            if self.__get_amount_of_players_on_base() <= 2:
                result += 1
        return self.weights[2] * result

    def estimate_targets(self, damage: int, affected_vehicles: list[Vehicle]) -> float:
        """
        Calculates an amount of kill points (potential and real) generated by the shot.

        """
        result = 0
        for vehicle in affected_vehicles:
            # hp_after_shot_modifier = damage / vehicle.hp
            if vehicle.hp <= damage:
                result += vehicle.max_hp
            # result += vehicle.capture_points * hp_after_shot_modifier

        return self.weights[3] * result

    def score_for_special_hexes(self, actor: Vehicle, position: Coords) -> float:
        """
        Check for any bonus hexes.

        Returns something not equal to zero if actor can benefit somehow
        from a at the given position.
        """
        pos_hex = self.game_state.get_hex(position).map_hex
        if isinstance(pos_hex, Catapult):
            return self.weights[4] * 1
        if isinstance(pos_hex, HardRepair) and type(actor) in pos_hex.served_classes:
            if actor.hp != actor.max_hp:
                return self.weights[4] * 1
        if isinstance(pos_hex, LightRepair) and type(actor) in pos_hex.served_classes:
            if actor.hp != actor.max_hp:
                return self.weights[4] * 1
        return 0

    def __get_potential_shooters(self, position: Coords) -> list[Vehicle]:
        result = []
        actor_gshex = self.game_state.get_hex(position)
        for vehicle in self.game_state.vehicles.values():
            if self.game_state.can_shoot(vehicle, actor_gshex):
                result.append(vehicle)

        return result

    def __get_amount_of_players_on_base(self):
        result = set()
        for vehicle in self.game_state.vehicles.values():
            vehicle_hex = self.game_state.get_hex(vehicle.position).map_hex
            if isinstance(vehicle_hex, Base):
                result.add(vehicle.player_id)

        return len(result)
